// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: t_y_raw_data_collection_pbf.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "TYRawDataCollectionPbf.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - TYRawDataCollectionPbfRoot

@implementation TYRawDataCollectionPbfRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - TYRawDataCollectionPbfRoot_FileDescriptor

static GPBFileDescriptor *TYRawDataCollectionPbfRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"innerpeacer.rawdata"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - TYRawStepEventPbf

@implementation TYRawStepEventPbf

@dynamic hasTimestamp, timestamp;

typedef struct TYRawStepEventPbf__storage_ {
  uint32_t _has_storage_[1];
  double timestamp;
} TYRawStepEventPbf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = TYRawStepEventPbf_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TYRawStepEventPbf__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TYRawStepEventPbf class]
                                     rootClass:[TYRawDataCollectionPbfRoot class]
                                          file:TYRawDataCollectionPbfRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TYRawStepEventPbf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TYRawHeadingEventPbf

@implementation TYRawHeadingEventPbf

@dynamic hasTimestamp, timestamp;
@dynamic hasHeading, heading;

typedef struct TYRawHeadingEventPbf__storage_ {
  uint32_t _has_storage_[1];
  double timestamp;
  double heading;
} TYRawHeadingEventPbf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = TYRawHeadingEventPbf_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TYRawHeadingEventPbf__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "heading",
        .dataTypeSpecific.className = NULL,
        .number = TYRawHeadingEventPbf_FieldNumber_Heading,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TYRawHeadingEventPbf__storage_, heading),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TYRawHeadingEventPbf class]
                                     rootClass:[TYRawDataCollectionPbfRoot class]
                                          file:TYRawDataCollectionPbfRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TYRawHeadingEventPbf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TYRawBeaconSignalPbf

@implementation TYRawBeaconSignalPbf

@dynamic hasUuid, uuid;
@dynamic hasMajor, major;
@dynamic hasMinor, minor;
@dynamic hasX, x;
@dynamic hasY, y;
@dynamic hasFloor, floor;
@dynamic hasRssi, rssi;
@dynamic hasAccuracy, accuracy;

typedef struct TYRawBeaconSignalPbf__storage_ {
  uint32_t _has_storage_[1];
  uint32_t major;
  uint32_t minor;
  uint32_t floor;
  uint32_t rssi;
  NSString *uuid;
  double x;
  double y;
  double accuracy;
} TYRawBeaconSignalPbf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "major",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Major,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, major),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minor",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Minor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, minor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_X,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, x),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Y,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, y),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "floor",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Floor,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, floor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rssi",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Rssi,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, rssi),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "accuracy",
        .dataTypeSpecific.className = NULL,
        .number = TYRawBeaconSignalPbf_FieldNumber_Accuracy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TYRawBeaconSignalPbf__storage_, accuracy),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TYRawBeaconSignalPbf class]
                                     rootClass:[TYRawDataCollectionPbfRoot class]
                                          file:TYRawDataCollectionPbfRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TYRawBeaconSignalPbf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TYRawLocationPbf

@implementation TYRawLocationPbf

@dynamic hasX, x;
@dynamic hasY, y;
@dynamic hasFloor, floor;

typedef struct TYRawLocationPbf__storage_ {
  uint32_t _has_storage_[1];
  uint32_t floor;
  double x;
  double y;
} TYRawLocationPbf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = TYRawLocationPbf_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TYRawLocationPbf__storage_, x),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = TYRawLocationPbf_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TYRawLocationPbf__storage_, y),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "floor",
        .dataTypeSpecific.className = NULL,
        .number = TYRawLocationPbf_FieldNumber_Floor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TYRawLocationPbf__storage_, floor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TYRawLocationPbf class]
                                     rootClass:[TYRawDataCollectionPbfRoot class]
                                          file:TYRawDataCollectionPbfRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TYRawLocationPbf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TYRawSignalEventPbf

@implementation TYRawSignalEventPbf

@dynamic hasTimestamp, timestamp;
@dynamic beaconsArray, beaconsArray_Count;
@dynamic hasLocation, location;
@dynamic hasImmediateLocation, immediateLocation;

typedef struct TYRawSignalEventPbf__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *beaconsArray;
  TYRawLocationPbf *location;
  TYRawLocationPbf *immediateLocation;
  double timestamp;
} TYRawSignalEventPbf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = TYRawSignalEventPbf_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TYRawSignalEventPbf__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "beaconsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TYRawBeaconSignalPbf),
        .number = TYRawSignalEventPbf_FieldNumber_BeaconsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TYRawSignalEventPbf__storage_, beaconsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(TYRawLocationPbf),
        .number = TYRawSignalEventPbf_FieldNumber_Location,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TYRawSignalEventPbf__storage_, location),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "immediateLocation",
        .dataTypeSpecific.className = GPBStringifySymbol(TYRawLocationPbf),
        .number = TYRawSignalEventPbf_FieldNumber_ImmediateLocation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TYRawSignalEventPbf__storage_, immediateLocation),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TYRawSignalEventPbf class]
                                     rootClass:[TYRawDataCollectionPbfRoot class]
                                          file:TYRawDataCollectionPbfRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TYRawSignalEventPbf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TYRawDataCollectionPbf

@implementation TYRawDataCollectionPbf

@dynamic hasDataId, dataId;
@dynamic hasTimestamp, timestamp;
@dynamic stepEventsArray, stepEventsArray_Count;
@dynamic headingEventsArray, headingEventsArray_Count;
@dynamic signalEventsArray, signalEventsArray_Count;

typedef struct TYRawDataCollectionPbf__storage_ {
  uint32_t _has_storage_[1];
  NSString *dataId;
  NSMutableArray *stepEventsArray;
  NSMutableArray *headingEventsArray;
  NSMutableArray *signalEventsArray;
  double timestamp;
} TYRawDataCollectionPbf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = TYRawDataCollectionPbf_FieldNumber_DataId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TYRawDataCollectionPbf__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = TYRawDataCollectionPbf_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TYRawDataCollectionPbf__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "stepEventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TYRawStepEventPbf),
        .number = TYRawDataCollectionPbf_FieldNumber_StepEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TYRawDataCollectionPbf__storage_, stepEventsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "headingEventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TYRawHeadingEventPbf),
        .number = TYRawDataCollectionPbf_FieldNumber_HeadingEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TYRawDataCollectionPbf__storage_, headingEventsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signalEventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TYRawSignalEventPbf),
        .number = TYRawDataCollectionPbf_FieldNumber_SignalEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TYRawDataCollectionPbf__storage_, signalEventsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TYRawDataCollectionPbf class]
                                     rootClass:[TYRawDataCollectionPbfRoot class]
                                          file:TYRawDataCollectionPbfRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TYRawDataCollectionPbf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\005A\000\003\000stepEvents\000\004\000headingEvents\000\005\000sign"
        "alEvents\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
